import { handleIncomingMessage, generateCustomsAdvice } from '../lib/gpt.js';
import { generateQuote, getTrackingInfo } from '../lib/ups.js';
import { validatePackageData, sanitizeInput, validateWebhookSignature } from '../lib/validation.js';
import { detectLanguage, extractPackageInfoAdvanced } from '../lib/units.js';
import logger from '../lib/logger.js';
import rateLimit from 'express-rate-limit';

// Rate limiting configuration
const limiter = rateLimit({
  windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 15 * 60 * 1000, // 15 minutes
  max: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS) || 100, // limit each IP to 100 requests per windowMs
  message: {
    error: 'Too many requests',
    message: 'Please wait a moment before sending another message.',
    retryAfter: Math.ceil((parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 900000) / 1000)
  },
  standardHeaders: true,
  legacyHeaders: false,
});

function extractPackageInfo(message) {
  // Use the advanced parser that handles multiple languages and units
  return extractPackageInfoAdvanced(message);
}

function extractTrackingNumber(message) {
  // UPS tracking numbers are typically 18 characters, starting with 1Z
  const upsMatch = message.match(/1Z[A-Z0-9]{16}/i);
  if (upsMatch) return upsMatch[0].toUpperCase();

  // Generic tracking number pattern
  const genericMatch = message.match(/[A-Z0-9]{10,20}/);
  if (genericMatch) return genericMatch[0].toUpperCase();

    
  return null;
}

export function parseDimensions(dimensionString) {
  if (!dimensionString || typeof dimensionString !== 'string') return null;
  
  const lowerDim = dimensionString.toLowerCase();
  
  // Look for patterns like "30x20x15 cm" or "12x8x6 inches"
  const cmMatch = lowerDim.match(/(\d+(?:\.\d+)?)\s*x\s*(\d+(?:\.\d+)?)\s*x\s*(\d+(?:\.\d+)?)\s*(cm|cent√≠metros?)/);
  const inchMatch = lowerDim.match(/(\d+(?:\.\d+)?)\s*x\s*(\d+(?:\.\d+)?)\s*x\s*(\d+(?:\.\d+)?)\s*(in|inches?|polegadas?)?/);
  
  if (cmMatch) {
    const [, l, w, h] = cmMatch;
    const length = parseFloat(l);
    const width = parseFloat(w);
    const height = parseFloat(h);
    
    return {
      length: length,
      width: width,
      height: height,
      unit: 'cm',
      inInches: {
        length: length * CM_TO_INCHES,
        width: width * CM_TO_INCHES,
        height: height * CM_TO_INCHES
      },
      inCm: {
        length: length,
        width: width,
        height: height
      }
    };
  }
  
  if (inchMatch) {
    const [, l, w, h] = inchMatch;
    const length = parseFloat(l);
    const width = parseFloat(w);
    const height = parseFloat(h);
    
    return {
      length: length,
      width: width,
      height: height,
      unit: 'in',
      inInches: {
        length: length,
        width: width,
        height: height
      },
      inCm: {
        length: length * INCHES_TO_CM,
        width: width * INCHES_TO_CM,
        height: height * INCHES_TO_CM
      }
    };
  }
  
  return null;
}

export function convertWeight(weight, fromUnit, toUnit) {
  if (fromUnit === toUnit) return weight;
  
  if (fromUnit === 'kg' && toUnit === 'lbs') {
    return weight * KG_TO_LBS;
  }
  
  if (fromUnit === 'lbs' && toUnit === 'kg') {
    return weight * LBS_TO_KG;
  }
  
  return weight;
}

export function convertDimensions(dimensions, fromUnit, toUnit) {
  if (fromUnit === toUnit) return dimensions;
  
  const convert = fromUnit === 'cm' && toUnit === 'in' ? CM_TO_INCHES : INCHES_TO_CM;
  
  return {
    length: dimensions.length * convert,
    width: dimensions.width * convert,
    height: dimensions.height * convert
  };
}

export function formatWeight(weight, unit, locale = 'en') {
  const formatted = parseFloat(weight).toFixed(1);
  
  if (locale.startsWith('pt')) {
    return unit === 'kg' ? `${formatted} kg` : `${formatted} libras`;
  } else {
    return unit === 'kg' ? `${formatted} kg` : `${formatted} lbs`;
  }
}

export function formatDimensions(dimensions, unit, locale = 'en') {
  const l = parseFloat(dimensions.length).toFixed(1);
  const w = parseFloat(dimensions.width).toFixed(1);
  const h = parseFloat(dimensions.height).toFixed(1);
  
  if (locale.startsWith('pt')) {
    const unitLabel = unit === 'cm' ? 'cm' : 'polegadas';
    return `${l} x ${w} x ${h} ${unitLabel}`;
  } else {
    const unitLabel = unit === 'cm' ? 'cm' : 'inches';
    return `${l} x ${w} x ${h} ${unitLabel}`;
  }
}

export function extractPackageInfoAdvanced(message) {
  try {
    const detectedUnits = detectUnits(message);
    const language = detectedUnits.language;
    
    logger.info('Parsing package info', { 
      detectedUnits, 
      messagePreview: message.substring(0, 100) 
    });
    
    // Parse weight
    const weightInfo = parseWeight(message);
    if (!weightInfo) return null;
    
    // Parse dimensions  
    const dimensionInfo = parseDimensions(message);
    if (!dimensionInfo) return null;
    
    // Extract CEP
    const cepMatch = message.match(/(\d{5}-?\d{3}|\d{8})/);
    if (!cepMatch) return null;
    
    // Convert everything to imperial for UPS API (UPS uses imperial)
    const weightInLbs = weightInfo.unit === 'kg' ? weightInfo.inLbs : weightInfo.value;
    const dimensionsInInches = dimensionInfo.unit === 'cm' ? dimensionInfo.inInches : {
      length: dimensionInfo.length,
      width: dimensionInfo.width,
      height: dimensionInfo.height
    };
    
    return {
      weight: weightInLbs,
      dimensions: dimensionsInInches,
      destination: {
        zip: cepMatch[1].replace(/\D/g, '')
      },
      original: {
        weight: weightInfo,
        dimensions: dimensionInfo,
        language: language
      }
    };
    
  } catch (error) {
    logger.error('Error parsing package info:', error);
    return null;
  }
}